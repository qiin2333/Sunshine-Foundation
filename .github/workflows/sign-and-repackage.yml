# 签名并重新打包工作流（仅用于正式发布版本）
# 1. 签名所有 EXE 和 DLL 文件
# 2. 使用签名后的文件重新打包 NSIS 和 ZIP
# 注意：只在正式发布（非预发布）时运行

name: Sign and Repackage (Release Only)

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      run-id:
        description: "Run ID to download artifact from"
        required: false
      release-tag:
        description: "Release tag"
        required: true

jobs:
  sign-and-repackage:
    name: Sign Files and Repackage
    runs-on: windows-latest
    # 只在正式发布时运行（不是预发布）
    if: ${{ (github.event_name == 'release' && !github.event.release.prerelease) || github.event_name == 'workflow_dispatch' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive

      # 1. 下载原始构建产物
      - name: Download build artifacts (from release)
        if: ${{ github.event_name == 'release' }}
        uses: dawidd6/action-download-artifact@v3
        with:
          workflow: main.yml
          name: sunshine-windows
          path: artifacts
          check_artifacts: true
          search_artifacts: true
          workflow_conclusion: success

      - name: Download build artifacts (manual with run-id)
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.run-id != '' }}
        uses: actions/download-artifact@v4
        with:
          name: sunshine-windows
          path: artifacts
          run-id: ${{ github.event.inputs.run-id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Download build artifacts (manual latest)
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.run-id == '' }}
        uses: dawidd6/action-download-artifact@v3
        with:
          workflow: main.yml
          name: sunshine-windows
          path: artifacts
          check_artifacts: true
          search_artifacts: true
          workflow_conclusion: success

      - name: List downloaded files
        shell: bash
        run: |
          echo "Downloaded files:"
          ls -laR artifacts/

      # 2. 解压 Portable ZIP 获取所有需要签名的文件
      - name: Extract Portable ZIP
        shell: bash
        run: |
          PORTABLE=$(find artifacts -name "*Portable*.zip" | head -n 1)
          if [ -n "$PORTABLE" ]; then
            echo "Extracting: $PORTABLE"
            mkdir -p unsigned-files
            7z x "$PORTABLE" -o"unsigned-files"
            echo "Extracted files:"
            ls -laR unsigned-files/
          else
            echo "No portable ZIP found"
            exit 1
          fi

      # 3. 上传所有未签名的文件（只一层结构）
      - name: Upload unsigned files for signing
        id: upload-unsigned
        uses: actions/upload-artifact@v4
        with:
          name: files-for-signing
          path: unsigned-files/

      # 4. 提交到 SignPath 签名（使用生产策略）
      - name: Submit to SignPath for signing
        uses: signpath/github-action-submit-signing-request@v1
        with:
          api-token: ${{ secrets.SIGNPATH_API_TOKEN }}
          organization-id: ${{ secrets.SIGNPATH_ORGANIZATION_ID }}
          project-slug: Sunshine-Foundation
          signing-policy-slug: release-signing
          artifact-configuration-slug: windows-portable
          github-artifact-id: "${{ steps.upload-unsigned.outputs.artifact-id }}"
          output-artifact-directory: signed-files
          wait-for-completion: true
          wait-for-completion-timeout-in-seconds: 600
          service-unavailable-timeout-in-seconds: 600

      # 5. 验证签名
      - name: Verify all signatures
        shell: pwsh
        run: |
          Write-Host "Verifying signatures..."
          $signedFiles = Get-ChildItem -Path "signed-files" -Recurse -File -Include *.exe,*.dll

          foreach ($file in $signedFiles) {
            Write-Host "`n=== $($file.Name) ==="
            $signature = Get-AuthenticodeSignature $file.FullName
            Write-Host "Status: $($signature.Status)"
            
            if ($signature.Status -ne "Valid") {
              Write-Error "Signature invalid for: $($file.Name)"
              exit 1
            }
          }
          Write-Host "`n✓ All signatures are VALID!" -ForegroundColor Green

      # 6. 使用签名后的文件重新打包 ZIP 便携版
      - name: Repackage signed Portable ZIP
        shell: bash
        run: |
          cd signed-files
          # 使用与输入一致的版本号
          if [ -n "${{ github.event.inputs.release-tag }}" ]; then
            VERSION="${{ github.event.inputs.release-tag }}"
          elif [ -n "${{ github.event.release.tag_name }}" ]; then
            VERSION="${{ github.event.release.tag_name }}"
          else
            VERSION="v$(date +%Y.%m%d)"
          fi
          7z a "../Sunshine-${VERSION}-Windows-Portable-Signed.zip" *
          cd ..
          echo "Created signed portable package:"
          ls -lh Sunshine-*-Portable-Signed.zip

      # 7. 重新构建项目以创建带签名文件的 NSIS 安装包
      - name: Setup MSYS2 for rebuild
        uses: msys2/setup-msys2@v2
        with:
          msystem: ucrt64
          update: false
          install: >-
            mingw-w64-ucrt-x86_64-cmake
            mingw-w64-ucrt-x86_64-ninja
            mingw-w64-ucrt-x86_64-nsis
            mingw-w64-ucrt-x86_64-toolchain
            mingw-w64-ucrt-x86_64-cppwinrt
            mingw-w64-ucrt-x86_64-curl-winssl
            mingw-w64-ucrt-x86_64-MinHook
            mingw-w64-ucrt-x86_64-miniupnpc
            mingw-w64-ucrt-x86_64-nlohmann-json
            mingw-w64-ucrt-x86_64-nodejs
            mingw-w64-ucrt-x86_64-onevpl
            mingw-w64-ucrt-x86_64-openssl
            mingw-w64-ucrt-x86_64-opus

      - name: Install Rust (for Tauri GUI)
        shell: msys2 {0}
        run: |
          echo "Installing Rust via rustup..."

          # Rust installs to Windows user directory
          WINDOWS_USER=$(cmd //c "echo %USERNAME%" | tr -d '\r')
          CARGO_BIN="/c/Users/${WINDOWS_USER}/.cargo/bin"
          export PATH="$CARGO_BIN:$PATH"

          # Check if cargo already exists
          if command -v cargo &> /dev/null; then
            echo "Rust already installed: $(cargo --version)"
          else
            # Download and install rustup
            curl --proto '=https' --tlsv1.2 -sSf https://win.rustup.rs/x86_64 -o /tmp/rustup-init.exe
            /tmp/rustup-init.exe -y --default-toolchain stable --profile minimal
            
            # Refresh PATH
            sleep 3
            export PATH="$CARGO_BIN:$PATH"
            
            # Verify installation
            if [ -f "$CARGO_BIN/cargo.exe" ]; then
              echo "Rust installed successfully: $(cargo --version)"
            else
              echo "Warning: Rust installed but cargo not found at $CARGO_BIN"
              exit 1
            fi
          fi
          
          # 安装 GNU target（MSYS2 环境需要）
          echo "Installing Rust GNU target..."
          rustup target add x86_64-pc-windows-gnu
          
          # 设置默认 target 为 GNU（避免使用 MSVC）
          rustup default stable-x86_64-pc-windows-gnu
          
          # 验证配置
          echo "Rust configuration:"
          rustc --version --verbose
          rustup show

      - name: Rebuild and package with signed files
        shell: msys2 {0}
        run: |
          echo "Rebuilding project with signed files..."

          # Add Rust to PATH
          WINDOWS_USER=$(cmd //c "echo %USERNAME%" | tr -d '\r')
          CARGO_BIN="/c/Users/${WINDOWS_USER}/.cargo/bin"
          export PATH="$CARGO_BIN:$PATH"

          # 重新配置 CMake
          mkdir -p build-signed
          cmake \
            -B build-signed \
            -G Ninja \
            -S . \
            -DBUILD_DOCS=OFF \
            -DSUNSHINE_ASSETS_DIR=assets

          # 编译（只需要生成必要的文件）
          ninja -C build-signed

          # 运行 cpack 生成暂存目录
          echo "=== Running cpack to generate staging directory ==="
          cd build-signed
          cpack -G NSIS --verbose || true
          
          # 定位 cpack 暂存目录
          STAGING_DIR="cpack_artifacts/_CPack_Packages/win64/NSIS/Sunshine"
          if [ ! -d "$STAGING_DIR" ]; then
            echo "Error: CPack staging directory not found at $STAGING_DIR"
            ls -la cpack_artifacts/_CPack_Packages/win64/NSIS/ 2>/dev/null || echo "NSIS directory doesn't exist"
            exit 1
          fi
          
          echo "=== Found CPack staging directory: $STAGING_DIR ==="
          
          # 使用固定的签名文件路径
          SIGNED_SRC="signed-files"
          echo "Using signed files from: $SIGNED_SRC"
          
          # 替换暂存目录中的签名文件
          echo "=== Replacing files in staging directory with signed versions ==="
          
          # 主程序 (application 组件) - 必须存在
          cp -fv "$SIGNED_SRC/sunshine.exe" "$STAGING_DIR/application/sunshine.exe"
          echo "✓ Replaced sunshine.exe"
          
          if [ -f "$SIGNED_SRC/zlib1.dll" ]; then
            cp -fv "$SIGNED_SRC/zlib1.dll" "$STAGING_DIR/application/zlib1.dll"
            echo "✓ Replaced zlib1.dll"
          fi
          
          # Tools (application/tools, audio/tools, dxgi/tools)
          for exe in "$SIGNED_SRC/"*.exe; do
            [ -f "$exe" ] || continue
            filename=$(basename "$exe")
            # 跳过主程序，已经处理过了
            if [ "$filename" = "sunshine.exe" ]; then
              continue
            fi
            cp -fv "$exe" "$STAGING_DIR/application/tools/$filename" 2>/dev/null && echo "✓ Replaced application/tools/$filename"
            cp -fv "$exe" "$STAGING_DIR/audio/tools/$filename" 2>/dev/null && echo "✓ Replaced audio/tools/$filename"
            cp -fv "$exe" "$STAGING_DIR/dxgi/tools/$filename" 2>/dev/null && echo "✓ Replaced dxgi/tools/$filename"
          done
          
          # GUI (Unspecified/assets/gui)
          if [ -f "$SIGNED_SRC/assets/gui/sunshine-gui.exe" ]; then
            cp -fv "$SIGNED_SRC/assets/gui/sunshine-gui.exe" "$STAGING_DIR/Unspecified/assets/gui/sunshine-gui.exe"
            echo "✓ Replaced GUI executable"
          fi
          
          if [ -f "$SIGNED_SRC/assets/gui/WebView2Loader.dll" ]; then
            cp -fv "$SIGNED_SRC/assets/gui/WebView2Loader.dll" "$STAGING_DIR/Unspecified/assets/gui/WebView2Loader.dll"
            echo "✓ Replaced WebView2Loader.dll"
          fi
          
          # 验证关键文件的签名
          echo "=== Verifying signatures in staging directory ==="
          powershell -Command "
            \$mainExe = Get-AuthenticodeSignature '$STAGING_DIR/application/sunshine.exe'
            Write-Host \"sunshine.exe signature: \$(\$mainExe.Status)\"
            if (\$mainExe.Status -eq 'NotSigned') {
              Write-Warning 'Main executable is not signed, but continuing with build...'
            } elseif (\$mainExe.Status -ne 'Valid') {
              Write-Error 'Main executable signature is invalid: \$(\$mainExe.Status)'
              exit 1
            } else {
              Write-Host '✓ Main executable signature is valid'
            }
          "
          
          # 手动运行 makensis 重新打包
          echo "=== Re-packaging with makensis ==="
          cd cpack_artifacts/_CPack_Packages/win64/NSIS
          makensis project.nsi
          
          # 移动生成的安装包
          if [ -f "Sunshine.exe" ]; then
            mv -fv "Sunshine.exe" "../../../Sunshine.exe"
            echo "✓ Installer created successfully"
          else
            echo "Error: Sunshine.exe not created"
            exit 1
          fi
          
          cd ../../..

          # 查找并移动安装包
          echo "Looking for installer..."
          if [ -f ./Sunshine.exe ]; then
            INSTALLER=./Sunshine.exe
          else
            echo "Error: Cannot find Sunshine.exe"
            find . -name "*.exe" -type f
            exit 1
          fi

          # 使用与 Portable ZIP 一致的版本号
          cd ..
          if [ -n "${{ github.event.inputs.release-tag }}" ]; then
            VERSION="${{ github.event.inputs.release-tag }}"
          elif [ -n "${{ github.event.release.tag_name }}" ]; then
            VERSION="${{ github.event.release.tag_name }}"
          else
            VERSION="v$(date +%Y.%m%d)"
          fi
          
          mv "build-signed/$INSTALLER" "Sunshine-${VERSION}-Windows-Installer-Signed.exe"
          echo "Created signed installer:"
          ls -lh Sunshine-*-Installer-Signed.exe

      # 8. 签名最终的 NSIS 安装包
      - name: Upload NSIS installer for final signing
        id: upload-nsis
        uses: actions/upload-artifact@v4
        with:
          name: nsis-for-final-signing
          path: Sunshine-*-Installer-Signed.exe

      - name: Sign NSIS installer
        uses: signpath/github-action-submit-signing-request@v1
        with:
          api-token: ${{ secrets.SIGNPATH_API_TOKEN }}
          organization-id: ${{ secrets.SIGNPATH_ORGANIZATION_ID }}
          project-slug: Sunshine-Foundation
          signing-policy-slug: release-signing
          artifact-configuration-slug: windows-installer
          github-artifact-id: "${{ steps.upload-nsis.outputs.artifact-id }}"
          output-artifact-directory: final-signed
          wait-for-completion: true
          wait-for-completion-timeout-in-seconds: 600
          service-unavailable-timeout-in-seconds: 600

      # 9. 验证最终签名
      - name: Verify final NSIS signature
        shell: pwsh
        run: |
          $installer = Get-ChildItem "final-signed" -Filter "*.exe" | Select-Object -First 1
          if ($installer) {
            Write-Host "Verifying NSIS installer signature..."
            $signature = Get-AuthenticodeSignature $installer.FullName
            Write-Host "Status: $($signature.Status)"
            if ($signature.Status -eq "Valid") {
              Write-Host "✓ NSIS installer signature is VALID!" -ForegroundColor Green
            }
          }

      # 10. 上传最终的签名文件
      - name: Upload final signed packages
        uses: actions/upload-artifact@v4
        with:
          name: sunshine-windows-fully-signed
          path: |
            Sunshine-*-Portable-Signed.zip
            final-signed/*.exe
          if-no-files-found: error

      # 11. 发布到 GitHub Release
      - name: Create Release
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.event.release.tag_name }}
          name: ${{ github.event.release.name }} (Signed)
          files: |
            Sunshine-*-Portable-Signed.zip
            final-signed/*.exe
          draft: true
          prerelease: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
