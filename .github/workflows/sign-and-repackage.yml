# 签名并重新打包工作流（仅用于正式发布版本）
# 流程：
# 1. 编译当前分支的代码（只编译一次）
# 2. 生成未签名的 ZIP 和 NSIS staging 目录
# 3. 将所有 EXE/DLL 文件提交到 SignPath 签名
# 4. 用签名文件重新打包 ZIP 便携版
# 5. 用签名文件替换 NSIS staging 目录中的文件并重新打包
# 6. 签名最终的 NSIS 安装包
# 注意：只在正式发布（非预发布）时运行，确保代码版本和签名文件一致

name: Sign and Repackage (Release Only)

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      release-tag:
        description: "Release tag for naming the output files"
        required: true

jobs:
  sign-and-repackage:
    name: Sign Files and Repackage
    runs-on: windows-latest
    # 只在正式发布时运行（不是预发布）
    if: ${{ (github.event_name == 'release' && !github.event.release.prerelease) || github.event_name == 'workflow_dispatch' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: recursive

      # 1. 设置构建环境
      - name: Setup MSYS2
        uses: msys2/setup-msys2@v2
        with:
          msystem: ucrt64
          update: false
          install: >-
            mingw-w64-ucrt-x86_64-cmake
            mingw-w64-ucrt-x86_64-ninja
            mingw-w64-ucrt-x86_64-nsis
            mingw-w64-ucrt-x86_64-toolchain
            mingw-w64-ucrt-x86_64-cppwinrt
            mingw-w64-ucrt-x86_64-curl-winssl
            mingw-w64-ucrt-x86_64-MinHook
            mingw-w64-ucrt-x86_64-miniupnpc
            mingw-w64-ucrt-x86_64-nlohmann-json
            mingw-w64-ucrt-x86_64-nodejs
            mingw-w64-ucrt-x86_64-onevpl
            mingw-w64-ucrt-x86_64-openssl
            mingw-w64-ucrt-x86_64-opus

      - name: Install Rust (for Tauri GUI)
        shell: msys2 {0}
        run: |
          echo "Installing Rust via rustup..."

          # Rust installs to Windows user directory
          WINDOWS_USER=$(cmd //c "echo %USERNAME%" | tr -d '\r')
          CARGO_BIN="/c/Users/${WINDOWS_USER}/.cargo/bin"
          export PATH="$CARGO_BIN:$PATH"

          # Check if cargo already exists
          if command -v cargo &> /dev/null; then
            echo "Rust already installed: $(cargo --version)"
          else
            # Download and install rustup
            curl --proto '=https' --tlsv1.2 -sSf https://win.rustup.rs/x86_64 -o /tmp/rustup-init.exe
            /tmp/rustup-init.exe -y --default-toolchain stable --profile minimal
            
            # Refresh PATH
            sleep 3
            export PATH="$CARGO_BIN:$PATH"
            
            # Verify installation
            if [ -f "$CARGO_BIN/cargo.exe" ]; then
              echo "Rust installed successfully: $(cargo --version)"
            else
              echo "Warning: Rust installed but cargo not found at $CARGO_BIN"
              exit 1
            fi
          fi
          
          # 安装 GNU target（MSYS2 环境需要）
          echo "Installing Rust GNU target..."
          rustup target add x86_64-pc-windows-gnu
          
          # 设置默认 target 为 GNU（避免使用 MSVC）
          rustup default stable-x86_64-pc-windows-gnu
          
          # 验证配置
          echo "Rust configuration:"
          rustc --version --verbose
          rustup show

      # 2. 构建项目（生成未签名的文件）
      - name: Build project
        shell: msys2 {0}
        run: |
          echo "Building project..."

          # Add Rust to PATH
          WINDOWS_USER=$(cmd //c "echo %USERNAME%" | tr -d '\r')
          CARGO_BIN="/c/Users/${WINDOWS_USER}/.cargo/bin"
          export PATH="$CARGO_BIN:$PATH"

          # 配置 CMake
          mkdir -p build
          cmake \
            -B build \
            -G Ninja \
            -S . \
            -DBUILD_DOCS=OFF \
            -DSUNSHINE_ASSETS_DIR=assets

          # 编译
          ninja -C build

          echo "Build completed successfully"

      # 3. 生成未签名的打包产物
      - name: Package unsigned files
        shell: msys2 {0}
        run: |
          cd build

          # 生成 ZIP 便携版（包含所有文件）
          cpack -G ZIP --verbose

          # 生成 NSIS 的 staging 目录（但不运行 makensis）
          echo "Generating NSIS staging directory..."
          cpack -G NSIS --verbose || true

          cd ..
          
          # 列出生成的文件
          echo "Generated files:"
          ls -lh build/cpack_artifacts/

      # 4. 解压 Portable ZIP 获取所有需要签名的文件
      - name: Extract files for signing
        shell: bash
        run: |
          PORTABLE=$(find build/cpack_artifacts -name "*.zip" | head -n 1)
          if [ -n "$PORTABLE" ]; then
            echo "Extracting: $PORTABLE"
            mkdir -p unsigned-files
            7z x "$PORTABLE" -o"unsigned-files"
            echo "Extracted files for signing:"
            ls -laR unsigned-files/
          else
            echo "No portable ZIP found"
            exit 1
          fi

      # 5. 上传所有未签名的文件到 SignPath
      - name: Upload unsigned files for signing
        id: upload-unsigned
        uses: actions/upload-artifact@v4
        with:
          name: files-for-signing
          path: unsigned-files/

      # 6. 提交到 SignPath 签名（使用生产策略）
      - name: Submit to SignPath for signing
        uses: signpath/github-action-submit-signing-request@v1
        with:
          api-token: ${{ secrets.SIGNPATH_API_TOKEN }}
          organization-id: ${{ secrets.SIGNPATH_ORGANIZATION_ID }}
          project-slug: Sunshine-Foundation
          signing-policy-slug: release-signing
          artifact-configuration-slug: windows-portable
          github-artifact-id: "${{ steps.upload-unsigned.outputs.artifact-id }}"
          output-artifact-directory: signed-files
          wait-for-completion: true
          wait-for-completion-timeout-in-seconds: 600
          service-unavailable-timeout-in-seconds: 600

      # 7. 验证签名
      - name: Verify all signatures
        shell: pwsh
        run: |
          Write-Host "Verifying signatures..."
          $signedFiles = Get-ChildItem -Path "signed-files" -Recurse -File -Include *.exe,*.dll

          foreach ($file in $signedFiles) {
            Write-Host "`n=== $($file.Name) ==="
            $signature = Get-AuthenticodeSignature $file.FullName
            Write-Host "Status: $($signature.Status)"
            
            if ($signature.Status -ne "Valid") {
              Write-Error "Signature invalid for: $($file.Name)"
              exit 1
            }
          }
          Write-Host "`n✓ All signatures are VALID!" -ForegroundColor Green

      # 8. 使用签名后的文件重新打包 ZIP 便携版
      - name: Repackage signed Portable ZIP
        shell: bash
        run: |
          cd signed-files
          # 使用与输入一致的版本号
          if [ -n "${{ github.event.inputs.release-tag }}" ]; then
            VERSION="${{ github.event.inputs.release-tag }}"
          elif [ -n "${{ github.event.release.tag_name }}" ]; then
            VERSION="${{ github.event.release.tag_name }}"
          else
            VERSION="v$(date +%Y.%m%d)"
          fi
          7z a "../Sunshine-${VERSION}-Windows-Portable-Signed.zip" *
          cd ..
          echo "Created signed portable package:"
          ls -lh Sunshine-*-Portable-Signed.zip

      # 9. 使用签名文件重新打包 NSIS 安装包
      - name: Repackage signed NSIS installer
        shell: msys2 {0}
        run: |
          echo "Repackaging NSIS installer with signed files..."

          # cpack 已经生成的 staging 目录（在步骤 3）
          CPACK_DIR="build/cpack_artifacts/_CPack_Packages/win64/NSIS"
          STAGING_DIR="$CPACK_DIR/Sunshine"

          # 检查 staging 目录是否存在
          if [ ! -d "$STAGING_DIR" ]; then
            echo "Error: NSIS staging directory not found: $STAGING_DIR"
            echo "Available directories:"
            ls -laR build/cpack_artifacts/
            exit 1
          fi

          # 替换为签名后的文件
          SIGNED_SRC="signed-files/Sunshine"
          
          echo "Replacing with signed files..."
          cp -fv "$SIGNED_SRC/sunshine.exe"                 "$STAGING_DIR/application/sunshine.exe"
          cp -fv "$SIGNED_SRC/zlib1.dll"                    "$STAGING_DIR/application/zlib1.dll"
          cp -fv "$SIGNED_SRC/tools/sunshinesvc.exe"        "$STAGING_DIR/application/tools/sunshinesvc.exe"
          cp -fv "$SIGNED_SRC/tools/qiin-tabtip.exe"        "$STAGING_DIR/application/tools/qiin-tabtip.exe"
          cp -fv "$SIGNED_SRC/tools/device-toggler.exe"     "$STAGING_DIR/assets/tools/device-toggler.exe"
          cp -fv "$SIGNED_SRC/tools/DevManView.exe"         "$STAGING_DIR/assets/tools/DevManView.exe"
          cp -fv "$SIGNED_SRC/tools/restart64.exe"          "$STAGING_DIR/assets/tools/restart64.exe"
          cp -fv "$SIGNED_SRC/tools/SetDpi.exe"             "$STAGING_DIR/assets/tools/SetDpi.exe"
          cp -fv "$SIGNED_SRC/tools/setreg.exe"             "$STAGING_DIR/assets/tools/setreg.exe"
          cp -fv "$SIGNED_SRC/tools/audio-info.exe"         "$STAGING_DIR/audio/tools/audio-info.exe"
          cp -fv "$SIGNED_SRC/tools/tools/dxgi-info.exe"    "$STAGING_DIR/dxgi/tools/dxgi-info.exe"
          cp -fv "$SIGNED_SRC/assets/gui/sunshine-gui.exe"  "$STAGING_DIR/Unspecified/assets/gui/sunshine-gui.exe"

          # 手动运行 makensis 重新打包
          echo "Running makensis to repackage installer..."
          makensis "$CPACK_DIR/project.nsi"

          # 使用与 Portable ZIP 一致的版本号
          if [ -n "${{ github.event.inputs.release-tag }}" ]; then
            VERSION="${{ github.event.inputs.release-tag }}"
          elif [ -n "${{ github.event.release.tag_name }}" ]; then
            VERSION="${{ github.event.release.tag_name }}"
          else
            VERSION="v$(date +%Y.%m%d)"
          fi
          
          mv -fv "$CPACK_DIR/Sunshine.exe" "Sunshine-${VERSION}-Windows-Installer-Signed.exe"
          echo "Created signed installer:"
          ls -lh Sunshine-*-Installer-Signed.exe

      # 10. 签名最终的 NSIS 安装包
      - name: Upload NSIS installer for final signing
        id: upload-nsis
        uses: actions/upload-artifact@v4
        with:
          name: nsis-for-final-signing
          path: Sunshine-*-Installer-Signed.exe

      - name: Sign NSIS installer
        uses: signpath/github-action-submit-signing-request@v1
        with:
          api-token: ${{ secrets.SIGNPATH_API_TOKEN }}
          organization-id: ${{ secrets.SIGNPATH_ORGANIZATION_ID }}
          project-slug: Sunshine-Foundation
          signing-policy-slug: release-signing
          artifact-configuration-slug: windows-installer
          github-artifact-id: "${{ steps.upload-nsis.outputs.artifact-id }}"
          output-artifact-directory: final-signed
          wait-for-completion: true
          wait-for-completion-timeout-in-seconds: 600
          service-unavailable-timeout-in-seconds: 600

      # 11. 验证最终签名
      - name: Verify final NSIS signature
        shell: pwsh
        run: |
          $installer = Get-ChildItem "final-signed" -Filter "*.exe" | Select-Object -First 1
          if ($installer) {
            Write-Host "Verifying NSIS installer signature..."
            $signature = Get-AuthenticodeSignature $installer.FullName
            Write-Host "Status: $($signature.Status)"
            if ($signature.Status -eq "Valid") {
              Write-Host "✓ NSIS installer signature is VALID!" -ForegroundColor Green
            }
          }

      # 12. 上传最终的签名文件
      - name: Upload final signed packages
        uses: actions/upload-artifact@v4
        with:
          name: sunshine-windows-fully-signed
          path: |
            Sunshine-*-Portable-Signed.zip
            final-signed/*.exe
          if-no-files-found: error

      # 13. 发布到 GitHub Release
      - name: Create Release
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.event.release.tag_name }}
          name: ${{ github.event.release.name }} (Signed)
          files: |
            Sunshine-*-Portable-Signed.zip
            final-signed/*.exe
          draft: true
          prerelease: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
